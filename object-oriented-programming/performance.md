
---

在计算机体系结构中，[内存墙](https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E5%A2%99)问题一直存在，并且有越来越严重的趋势，而OOP有加重这种趋势的倾向。

OOP编程可能不是cache friendly，跟并行比较的话：OO要求封装，并行要求开放；OO要array of struct,并行要struct of array；OO要求灵气和操作绑定，并行要求数据和操作分离。

##### 1. 过度封装

使用OOP时，会把一些复杂的问题分拆抽象成较简单的独立对象，通过对象的互相调用去实现方案。但是，由于对象包含自己封装的数据，一个问题的数据集会被分散在不同的内存区域。互相调用时很可能会出现数据的cache miss的情况。

##### 2. 多态

在C++的一般的多态实现中，会使用到虚函数表。虚函数表是通过加入一次间接层来实现动态派送。但在调用的时候需要读取虚函数表，增加cache miss的可能性。基本上要支持动态派送，无论用虚函数表、函数指针都会形成这个问题，但如果类的数目极多，把函数指针如果和数据放在一起有时候可放缓问题。

##### 3. 数据布局

虽然OOP本身并无限制数据的布局方式，但基本上绝大部分OOP语言都是把成员变量连续包裹在一段内存中。甚至使用C去编程的时候，也通常会使用到OOP或Object-based的思考方式，把一些相关的数据放置于一个struct之内：

```
struct Particle {
    Vector3 position;
    Vector4 velocity;
    Vector4 color;
    float age;
    // ...
}

```

即使不使用多态，我们几乎不加思索地会使用这种数据布局方式。我们通常会以为，由于各个成员变量都紧凑地放置在一起，这种数据布局通常对缓存友好。然而，实际上，我们需要考虑数据的存取模式（access pattern）。

在OOP中，通过封装，一个类的各种功能会被实现为多个成员函数，而每个成员函数实际上可能只会存取少量的成员变量。这可能形式非常严重的问题，例如：

```
for (Particle* p = begin; p != end; ++p)
    p->position += p->velocity * dt; // 或 p->SimulateMotion(dt);
    
```

在这种模式下，实阶上只存取了两个成员变量，但其他成员变量也会载入缓存造成浪费。当然，如果在迭代的时候能存取尽量多的成员变量，这个问题可能并不存在，但实际上是很困难的。

如果采用传统的OOP编程范式及实现方式，数据布局的问题几乎没有解决方案。所以在某些情况下，应该放弃OOP方式，以数据的存取及布局为编程的考虑重中，称作面向数据编程（data-oriented programming, DOP）。

多态的确影响性能，且难以优化。问题1、3可以用并行数组和mempool来解决。将结构体中的常用数据和不常用数据分开，这样一个cache line读36字节，能命中能多有效信息。同时自己构建一个内存池，所有类从该内存池获得内存，这样就可以用内存大页提高tlb命中率。

游戏方面，CPU性能很少成为瓶颈。客户端一般是GPU瓶颈，服务器一般是IO瓶颈。

---
#### References

1. [面向对象编程的弊端是什么？ - Milo Yip的回答 - 知乎](https://www.zhihu.com/question/20275578/answer/27046327)