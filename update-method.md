
---

没错，就是你在游戏编程中常见的Update\(\)或Tick\(\)方法，这可能是在游戏开发中最常见的模式了，常见到一直以来我并不认为它算得上是一种模式。

在Update\(\)中使用Hashtable可能问题包括：

1. 遍历顺序不稳定

---

#### 在Update\(\)期间修改对象列表时必须谨慎

新加入的对象通常不应该在本帧更新，原因至少包括两点：一是因为此时玩家尚未看到这个物品，二是更新该对象有可能进一步导致创建或销毁新的对象。如果你不希望这样的情况发生，一个简单的办法就是在遍历之前存储当前对象列表的长度，而这一次的循环仅更新列表前面这么多的对象。

更令人担忧的问题是遍历时移除对象，这有可能会导致某些对象在本帧被更新两次，以及其它的某些对象在本帧一次也更新不到的情况。

---

#### 避免使用Hashtable类容器遍历对象

Hashtable设计的主要目标是根据key值快速的index/add/remove，这些操作的平均时间复杂度都是O\(1\)的。它的设计理念就决定了它在存储上存在着随机的成分，因此当Hashtable容量发生变化的时候，其遍历顺序很可能发生变化。在游戏中，所有对象都在每帧进行模拟，但**并非真正同步**。游戏循环在每帧遍历对象并逐个更新它们，在Update\(\)的调用中，**多数对象能够访问到游戏世界的其它部分，包括那些正在更新的其它对象**，这意味着，游戏循环遍历更新对象顺序意义重大。因此，基于遍历顺序不稳定的Hashtable进行对象更新可能会引入不易重现的bug。

Hashtable的遍历速度可能只有array的几分之一，在Unit3d中实测C\#各容器的遍历开销对比如下，其中SortedTable为自定义映射表，基于array使用二分查找实现：

| 函数 | 遍历类型 | cpu开销 | gc开销 |
| --- | --- | --- | --- |
| SortedTable | Pair | 6 | 0 |
|  | Values | 2 | 0 |
|  | **Values\[i\]** | **1** | **0** |
| Dictionary | Pair | 7 | 0 |
|  | Values | 8 | 12B |
| Hashable | Pair | 4 | 36B |
|  | Values | 3 | 36B |
| SortedDictionary | Pair | 18 | 100B |
|  | Values | 13 | 112B |



