

---

继承和多态必须一起说，一旦割裂，就说明理解上已经误入歧途了。

先说继承，继承同时具有两种含义：

1. 实现继承：继承基类的方法，并做出自己的扩展 -- 号称解决了代码重用问题；
2. 接口继承：声明某个子类在接口上完全兼容于某基类，外部调用者可无需关注其差别（LSP）；

再说多态：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。

很显然，多态实际上是依附于继承的第二种含义的。让它与封装、继承这两个概念并列，是不符合逻辑的。不假思索的就把它们当作可并列概念使用的人，显然是从一开始就被误导了。

实践中，继承的第一种含义（实现继承）意义并不很大，甚至常常是有害的，因为它使得子类与基类出现强耦合。

继承的第二种含义非常重要。它又叫“接口继承”。

**接口继承实质上是要求“做出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理实现了特定接口的所有对象”——这在程序设计上，叫做归一化**。

归一化使得外部使用者可以不加区分的处理所有接口兼容的对象集合——就好象linux的泛文件概念一样，所有东西都可以当文件处理，不必关心它是内存、磁盘、网络还是屏幕（当然，如果你需要，当然也可以区分出“字符设备”和“块设备”，然后做出针对性的设计：细致到什么程度，视需求而定）。

归一化的实例：

1. 一切对象都可以序列化/ToString
1. 一切UI对象都是个window，都可以响应窗口事件。

-- 必须注意，是一切（符合xx条件的）对象皆可以做什么，而不是“一切皆对象”，后者毫无意义。

显然，归一化可以大大简化使用者的处理逻辑：这和带兵打仗是类似的，班长需要知道每个战士的姓名/性格/特长，否则就不知道该派谁去对付对面山坡上的狙击手；而连长呢，只需知道自己手下哪个班/排擅长什么就行了，然后安排他们各自去守一段战线；到了师长/军长那里，他更关注战场形势的转变及预期……没有这种层层简化、而是必须直接指挥到每个人的话，累死军长都没法指挥哪怕只是一场形势明朗的冲突——光一个个打完电话就能把他累成哑巴。

软件设计同样。比如说，消息循环在派发消息时，只需知道所有UI对象都是个window，都可以响应窗口消息就足够了；它没必要知道每个UI对象究竟是什么——该对象自己知道收到消息该怎么做。

合理划分功能层级、适时砍掉不必要的繁杂信息，一层层向上提供简洁却又完备的信息/接口，高层模块才不会被累死——KISS是最难也是最优的软件设计方法，没有之一。

**在业务逻辑层面的继承树层次不要超过3层**

---
#### References

1. [面向对象编程的弊端是什么？ - invalid s的回答 - 知乎](https://www.zhihu.com/question/20275578/answer/26577791)