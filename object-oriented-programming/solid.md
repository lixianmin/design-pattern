
---

#### S.O.L.I.D五原则

S.O.L.I.D 原则，由Robert  Martin提出，它们是五个面向对象通用设计原则的首字母缩写，用于更好编写面向对象程序。

这五个设计原则分别是：

| 缩写 | 全名 | 中文名 |
| --- | --- | --- |
| **S**RP | Single Responsibility Principle | 单一职责 |
| **O**CP | Open / Closed Principle | 开闭原则 |
| **L**SP | Liskov Substitution Principle | 里氏替换 |
| **I**SP | Interface Segregation Principle | 接口分离 |
| **D**IP | Denpendency Inversion Principle | 依赖倒置 |

---

#### SRP 单一职责原则

1. 就一个类而言，应该仅有一个引起它变化的原因；
2. 有时候你会发现，某个类中的一半子程序使用着该类的一半数据，而另一半子程序则使用另一半数据。这时你其实已经把两个类混在一直使用了，把它们拆开吧；
3. 减少类之间的依赖关系，提高系统的可维护性，减少类修改时需要重新编译的文件数目，降低适应变化的成本；

---

#### OCP 开闭原则

对扩展开放，对修改关闭（Open for extension, but closed for modification）。OCP认为软件设计应该尽可能地使架构稳定而又容易满足不同的需求。  
实现OCP的主要手段是使用信息隐藏，这也是敏捷软件开发的指导思想之一。信息隐藏可以应用于软件设计的各个层次，这是一个需要时刻贯彻的原则。信息隐藏的手法包括但不限于：  
1. 使用typedef定义一个具有抽象意义的名称，而不是使用C++的原生数据类型：比如，你需要一个id去唯一的标识某个类的对象，你应该使用typedef  int  IdType; 定义一个IdType类型，而不是暴露原生的int类型，这样可以确保当IdType的数据类型改变时代码的改动最小；  
2. 使用函数而不要去直接操作原生数据：比如，很多类都会包含一些属性对象，对象的会存在一些set, get函数对，我们约定：除了在构造函数中外，所有的属性对象值的设置一律使用set函数，而不是直接修改对象变量的值，哪怕set函数中仅存一句赋值语句。set函数保留修改的权力；  
3. 代码应该依赖抽象，而不是依赖实现：即，针对接口编程，而不是针对实现编程；  
4. “尽量”使用file域变量代替全局变量和类static成员变量：  
在.cpp文件的全局域中定义的变量是全局变量，即使您没有在.h文件使用extern进行声明，这在存在多份定义式的情况下会起链接问题；  
在.cpp文件中使用static定义的变量是file域的，这是继承自c的一个用法。c++不鼓励使用static变量；  
在.cpp文件中的匿名namespace中定义的变量或函数是file域的；  
建议使用定义于.cpp文件中的匿名namespace成员代替定义于.h文件中的类static成员，这样可以更好的支持信息隐藏；

---

#### LSP 里氏替换原则

1. 确保sub-class是一个sub-type；
2. 老鼠的儿子会打洞：继承必须确保超类所拥有的性质在子类中仍然成立，即当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系；
3. \(Refused Bequest\)如果子类仅仅需要父类的部分methods或data\(而不是全部\)时，就意味这我们的继承体系出现了问题；

---

#### ISP 接口隔离原则

```
在一棵接口继承树下，当一个子类由于功能扩展需要添加一个新的方法接口时，如果将接口添加到了共用接口中，则会导致共用胖接口问题：
```

1. 其它不需要该接口的子类同样必须提供该接口的退化\(degenerate\)实现，这有可能违反ISP；
2. 客户代码会依赖于他们完全不使用的代码，从而导致连锁编译；

---

#### DIP 依赖倒置原则

DIP是层次化设计指导原则，它强化了模块之间的独立性（而不是稳定性，后者决定于具体代码实现）：  
1. 依赖关系倒置：高层模块与低层模块之间不应该存在直接的依赖关系，它们都依赖于抽象，程序中所有的依赖关系中止于接口；  
2. 接口所有权倒置：代码接口应该高层模块定义，低层模块实现，而不是相反（Hollywood原则：Don't call us, we will call you!）；或者说细节应该依赖于抽象，而不是抽象依赖于细节；





